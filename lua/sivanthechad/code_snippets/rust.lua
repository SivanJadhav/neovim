return function(ls, s, t, i) {
	ls.add_snippet("rust", {
		s("rcp", t({
		"/*",
		" * Problem: [Contest + Problem Name]",
		" * Link: [Direct problem link]",
		" * Difficulty: [Your assessment]",
		" * ",
		" * Solution Approach: [Brief explanation]",
		" * Time/Space Complexity: [Analysis]",
		" */",
    "use std::io::{self, BufRead};",
    "",
    "// Scanner struct",
    "struct Scanner<R> {",
    "    reader: R,",
    "    buffer: Vec<String>,",
    "}",
    "",
    "impl<R: BufRead> Scanner<R> {",
    "    fn new(reader: R) -> Self {",
    "        Self {",
    "            reader,",
    "            buffer: Vec::new(),",
    "        }",
    "    }",
    "",
    "    fn next<T: std::str::FromStr>(&mut self) -> T {",
    "        loop {",
    "            if let Some(token) = self.buffer.pop() {",
    "                return token.parse::<T>().ok().unwrap();",
    "            }",
    "            let mut line = String::new();",
    "            self.reader.read_line(&mut line).unwrap();",
    "            self.buffer = line",
    "                .split_whitespace()",
    "                .rev()",
    "                .map(String::from)",
    "                .collect();",
    "        }",
    "    }",
    "",
    "    fn next_vec<T: std::str::FromStr>(&mut self) -> Vec<T> {",
    "        let mut line = String::new();",
    "        self.reader.read_line(&mut line).unwrap();",
    "        line.split_whitespace()",
    "            .map(|x| x.parse::<T>().ok().unwrap())",
    "            .collect()",
    "    }",
    "",
    "    fn next_tuple<T: std::str::FromStr, U: std::str::FromStr, V: std::str::FromStr>(&mut self) -> (T, U, V) {",
    "        (self.next(), self.next(), self.next())",
    "    }",
    "}"
		}))
	})
}
